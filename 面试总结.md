## 进阶

- SpringCloud核心组件及其原理
- 分布式事务解决方案及Java实现
- Redis常用数据类型、分布式锁、缓存雪崩相关问题、持久化流程及机制
  - Redis数据结构：
    -  String
    -  Hash(一个key可存储多个字段名及数值，常用于存储对象)。
    - List(按照插入顺序，可将数据添加至头部或者尾部，可用于消息队列)。
    - Set(无序，不可重复,通过hash实现，增加，删除，查询复杂度都是O(1)，优势在于方便集合的操作 :并集、交集、差集计算)。
    -  SortedSet(有序集合，不可重复,有插入顺序,按score排序) 。
  -  Redis实现分布式锁
    - 原理：利用Redis的**setnx命令**。此命令同样是原子性操作，只有在key不存在的情况下，才能set成功
    - 异常场景及处理方式
      - 场景一：线程a任务未执行完成，锁过期，可能导致该锁被别的线程b获取到，a执行完后删除锁(此时为B的锁)
        - 解决方案：释放锁时判断此时的锁是否为自己加的锁(设置锁的key与线程id相关，或者判断该锁的value<UUid>是否为自己设置的)
      - 优化：上述场景可能该任务同时执行两次，不够完美。
        - 解决方案：让获取到锁的线程增加一个守护线程，当快过期但是任务还没执行完时，让守护线程去更新时间，执行expire命令。
  - 缓存穿透、缓存雪崩、缓存击穿原因及现象、解决方案
    - 缓存穿透
      - 原因及现象：数据或代码问题或恶意攻击频繁访问不存在的数据，在缓存和数据库都获取不到该数据，导致后端数据库压力过大甚至宕机。
      - 解决方案：统计调用次数及命中率，命中率过低时缓存空值进行保护(设置value为Null)或布隆过滤器。
    - 缓存雪崩
      - 原因及现象：大量key同时过期或者缓存服务器宕机，导致大量请求同时到达数据库，数据库压力过大可能导致系统雪崩。
      - 解决方案：同时过期：key过期时间设置随机值，不同的key设置不同的过期时间；服务器宕机：搭建redis集群。
    - 缓存击穿
      - 原因及现象：并发情况下，大量请求同时访问热点key，某个时间点，刚好该key过期，此时多个线程会同时从数据库中读取数据刷新到缓存中，造成数据库压力过大。
      - 解决方案：使用分布式锁，只允许一个线程去刷新缓存，其他线程等待缓存刷新好之后从缓存中拿即可。
  - Redis的持久化流程及机制
    - 持久化流程
    - RDB:默认的持久化机制，在指定的时间间隔内将内存中的数据集快照进磁盘。即将内存中的数据以快照的方式写入二进制文件中，默认的文件名为dump.rdb。(全量备份)
      - 触发机制
        - sava触发方式：该命令会阻塞当前redis服务器，在执行期间，redis不能处理其他命令。
        - bgsava触发方式：redis后台异步执行快照操作，同时可处理其他命令。通过创建子进程，持久化过程通过子进程实现。
        - 自动触发：通过配置redis.conf自动触发bgsave实现。例如：在m秒内至少有n个key被修改，则会触发bgsave。（save m n）
    - AOF：redis会将收到的每一个写命令通过write函数追加到文件中，即日志记录。
      - 触发机制
        - always:同步持久化，每次发生数据变更，都会被记录；
        - everysec：每秒同步，如果一秒内宕机，会丢失数据;
        - no:从不同步
- Mysql如何优化？MySQL索引及其索引失效场景
- SpringMVC执行流程及SpringBoot启动流程
- JVM内存结构及类加载机制
- 线程池
- 并发编程包
- 



## 基础

- 线程的实现方式
- String、StringBuffer、StringBuild
- MybatisXML中常用标签
- 